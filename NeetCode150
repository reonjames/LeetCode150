*****Heap question*****
# 703. Kth Largest Element in a Stream

import java.util.PriorityQueue;

class KthLargest {
    private int k;
    private PriorityQueue<Integer> minHeap;

    public KthLargest(int k, int[] nums) {
        this.k = k;
        minHeap = new PriorityQueue<>();

        // Add initial numbers to the min-heap
        for (int num : nums) {
            add(num);
        }
    }

    public int add(int val) {
        // If the heap has fewer than k elements, add the new value
        if (minHeap.size() < k) {
            minHeap.offer(val);
        }
        // If the new value is greater than the smallest in the heap, replace it
        else if (val > minHeap.peek()) {
            minHeap.poll();
            minHeap.offer(val);
        }

        // The top of the min-heap is the k-th largest element
        return minHeap.peek();
    }
}

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest obj = new KthLargest(k, nums);
 * int param_1 = obj.add(val);
 */
 
 # 1046. Last Stone Weight

 
 class Solution {
    public int lastStoneWeight(int[] stones) {
        PriorityQueue<Integer> q= new PriorityQueue<>(new CustomComparator());
        for(int i=0;i<stones.length;i++){
            q.add(stones[i]);
        }
        while(q.peek()!=null){
            if(q.size()>1){
                int first = q.poll();
                int second = q.poll();
                if(first!=second){
                    q.add(first-second);
                }
            }else if(q.size()==1)
                    return q.peek();
        }
        return 0;
    }
    
}
class CustomComparator implements Comparator<Integer>{
    public int compare(Integer a,Integer b){
        int value= a.compareTo(b);
        if(value>0)
            return -1;
        else if(value<0)
            return 1;
        return 0;        
    }
}

#973. K Closest Points to Origin


import java.util.Map.Entry;
class Solution {
    public int[][] kClosest(int[][] points, int k) {
        PriorityQueue<Double>index= new PriorityQueue<>(Comparator.reverseOrder());
        HashMap<Integer,Double> map = new HashMap<>();
        int[][] result = new int[k][];
        int q=0;
        for(int i=0;i<points.length;i++){
            double sqrt = Math.sqrt(points[i][0]*points[i][0]+points[i][1]*points[i][1]);
            
            if(index.size()!=k){
                index.offer(sqrt);
                map.put(i,sqrt);
            }else if(index.peek()>sqrt){
                for(Entry<Integer,Double> entry: map.entrySet()){
                    
                    if(entry.getValue().equals(index.peek())){
                        map.remove(entry.getKey());
                        
                    }    
                }
                index.poll();
                index.offer(sqrt);
                map.put(i,sqrt);
            }
        }
        //System.out.println("map="+map);
        //System.out.println("index="+index);
        // Iterator<Double> itr = index.iterator();
        // while(itr.hasNext()){
        //     result[q++]=points[map.get(itr.next())];
        // }
        for(Entry<Integer,Double> entrys: map.entrySet()){
            result[q++]=points[entrys.getKey()];
        }
        return result;
    }

}
// class customComparator implements Comparator<Double>{
//     double compare(double a,double b){
//         if(a>b)
//             return -1;
//         if(a<b)
//             return 1;
//         return 0;        
//     }
// }

# 295. Find Median from Data Stream

class MedianFinder {
    PriorityQueue<Integer>secondHalf;
    PriorityQueue<Integer>firstHalf;

    public MedianFinder() {
        secondHalf = new PriorityQueue<>();
        firstHalf = new PriorityQueue<>((a,b)->b-a);
    }
    
    public void addNum(int num) {
     firstHalf.offer(num);
     secondHalf.offer(firstHalf.poll());
     if(firstHalf.size()<secondHalf.size()){
        firstHalf.offer(secondHalf.poll());
     }   
    }
    
    public double findMedian() {
        double result=0.0;
        if(firstHalf.size()>secondHalf.size())
            result = firstHalf.peek();
        else if(firstHalf.size()==secondHalf.size()){
            result = (firstHalf.peek()+secondHalf.peek())/2.0;
        } 
        return result;   
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
 
 ******Tree******
 # 104 Maximum depth of Binary tree
 
 /**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        int depth=0;
        if(root==null){
            depth=0;
            return depth;
        }else{
            int ldepth=1+maxDepth(root.left);
            int rdepth=1+maxDepth(root.right);
            depth = Math.max(ldepth,rdepth);
            return depth;   
        }
        //return depth;
    }
}
# 543 Diameter of Binary Tree

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int res=0;
    public int diameterOfBinaryTree(TreeNode root) {
        
        dfs(root);
        return res;
    }
    public int dfs(TreeNode root){
        if(root==null){
            return 0;
        }
        int left = dfs(root.left);
        int right = dfs(root.right);
        res = Math.max(res,left+right);
        return 1+Math.max(left,right);
    }
}

# 110 Balanced Binary Tree

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int flag = 0;
    public boolean isBalanced(TreeNode root) {
        dfs(root);
        if(flag == 0)
            return true;
        else
            return false;    
    }
    public int dfs(TreeNode root){
        if(root==null){
            return 0;
        }
        int left = dfs(root.left);
        int right = dfs(root.right);
        if(Math.abs(left-right)>1){
            flag=1;
        }
        return Math.max(left,right)+1;
    }
}
